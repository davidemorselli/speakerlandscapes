#' Plot Speaker Landscapes
#'
#' Takes the UMAP coordinates generated by \code{make_speaker_landscapes} and creates
#' a scatter plot visualizing the distribution of speakers, optionally colored
#' by category, and labeled by key word tokens.
#'
#' @param speaker_landscape A \code{list} object returned by the \code{make_speaker_landscapes}
#'   function, containing the UMAP-reduced coordinates for both speakers (\code{$speakers})
#'   and words (\code{$words}). This list must contain columns named \code{X1} and \code{X2}
#'   for coordinates.
#' @param size_points A numeric value specifying the size of the speaker points in the plot.
#'   This controls the visual prominence of individual speakers. Defaults to \code{.3}.
#' @param alpha_points A numeric value specifying the transparency (alpha) of the
#'   speaker points in the plot (ranging from 0.0 for fully transparent to 1.0 for opaque).
#'   A low alpha value is often recommended when plotting dense speaker data to reveal
#'   cluster density and overlap. Defaults to \code{.3}.
#' @param categories Optional: A data frame or tibble with columns named \code{author}
#'   (containing speaker identifiers that match the training data) and a column named
#'   \code{categories} (containing the categorical classification or grouping for those speakers).
#'   If supplied, the speaker points are colored according to these categories, and a legend is displayed.
#'   Defaults to \code{NULL}.
#'
#' @return A \code{ggplot} object visualizing the UMAP reduction. This object can be further
#'   customized or saved using standard \code{ggplot2} functions.
#'
#' @details
#' This function generates the final visualization of the embedding analysis. The plot displays
#' the two-dimensional mapping of the vector space, where distance represents **semantic similarity**.
#'
#' **Interpretation Components:**
#' \itemize{
#'   \item **Speaker Points:** Each point represents a unique speaker, positioned based on their overall
#'     linguistic profile. Dense clusters indicate groups of speakers who share similar vocabulary
#'     and contextual patterns. The **alpha transparency** is deliberately low by default to allow
#'     visual aggregation of these clusters.
#'   \item **Word Labels:** The black text labels represent key tokens (e.g., specific terms, names, or n-grams)
#'     that were projected into the same space. The proximity of a speaker cluster to a word label
#'     suggests that the speakers in that cluster use that word or related words in a **contextually similar way**
#'     to define their overall voice.
#'   \item **Styling:** The plot utilizes a minimal theme, explicitly suppressing axis titles, text, ticks,
#'     and grid lines. This decision centers the viewer's attention entirely on the relative
#'     positioning of points and labels, reinforcing the interpretation of the map as a **semantic landscape**.
#' }
#'
#' @importFrom ggplot2 ggplot aes geom_point geom_text theme_minimal theme element_blank
#' @importFrom dplyr %>% mutate left_join
#'
#' @examples
#' \dontrun{
#' library(ggplot2)
#' library(dplyr)
#'
#' # --- Placeholder Data Structures (matching make_speaker_landscapes output) ---
#' # Assume 'landscape_data' was generated by make_speaker_landscapes()
#' landscape_data <- list(
#'   speakers = tibble::tibble(author = c("A", "B", "C", "D"), n_quotes = 10, X1 = 1:4, X2 = 4:1),
#'   words = tibble::tibble(words = c("cat", "dog"), X1 = c(2.5, 3.5), X2 = c(3.5, 2.5))
#' )
#'
#' # Example 1: Basic plot
#' plot_speaker_landscapes(landscape_data)
#'
#' # Example 2: Plot with categories
#' speaker_categories <- tibble::tibble(
#'   author = c("A", "B", "C", "D"),
#'   categories = c("Group 1", "Group 2", "Group 1", "Group 2")
#' )
#' plot_speaker_landscapes(landscape_data, categories = speaker_categories)
#'
#' # Example 3: Customized plot using ggplot2 piping
#' plot_speaker_landscapes(landscape_data) +
#'   ggplot2::labs(title = "UMAP Speaker & Word Landscape") +
#'   ggplot2::scale_color_brewer(palette = "Set1")
#' }
plot_speaker_landscapes <- function(speaker_landscape,
                                    size_points = .3,
                                    alpha_points = .3,
                                    categories = NULL) {

  # Extract data from the list returned by make_speaker_landscapes
  df_final <- speaker_landscape$speakers
  low_dim_words <- speaker_landscape$words

  # Handle optional categories join
  if (!is.null(categories)) {
    # Assuming 'categories' has columns 'author' and 'categories'
    df_final <- df_final %>%
      dplyr::left_join(categories, by = "author")
  } else {
    # Create a dummy variable for color if no categories provided
    df_final <- df_final %>% dplyr::mutate(categories = "Uncategorized")
  }

  # --- Generate Plot ---
  plot_obj <- df_final %>%
    ggplot2::ggplot(ggplot2::aes(x = X1, y = X2)) +

    # Plot Speaker Points
    ggplot2::geom_point(ggplot2::aes(color = categories), size = size_points, alpha = alpha_points) +

    # Add Word Labels
    ggplot2::geom_text(
      data = low_dim_words,
      mapping = ggplot2::aes(x = X1, y = X2, label = words),
      inherit.aes = FALSE,
      check_overlap = TRUE,
      color = "black",
      size = 4,
      alpha = 1
    ) +

    # Apply Theme
    ggplot2::theme_minimal() +
    ggplot2::theme(
      panel.grid.major = ggplot2::element_blank(),
      panel.grid.minor = ggplot2::element_blank(),
      panel.border = ggplot2::element_blank(),
      axis.line = ggplot2::element_blank(),
      axis.title.x = ggplot2::element_blank(),
      axis.text.x = ggplot2::element_blank(),
      axis.ticks.x = ggplot2::element_blank(),
      axis.title.y = ggplot2::element_blank(),
      axis.text.y = ggplot2::element_blank(),
      axis.ticks.y = ggplot2::element_blank(),
      legend.position = if (is.null(categories)) "none" else "right" # Show legend only if categories are provided
    )

  return(plot_obj)
}
