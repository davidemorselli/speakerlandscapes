% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_speaker_landscapes.R
\name{make_speaker_landscapes}
\alias{make_speaker_landscapes}
\title{Load, Process, and Prepare Speaker Landscapes with UMAP}
\usage{
make_speaker_landscapes(
  data,
  embedding = NULL,
  tokens_to_plot = NULL,
  speaker_identifier = "speaker",
  retain_threshold = 5,
  umap_seed = 42,
  n_neighbors = 40,
  min_dist = 0.01
)
}
\arguments{
\item{data}{The input source. Can be a character string specifying the path to
the space-separated file OR a character vector where each element is a line
of text (in which case its class must be set to \code{"speakers_text"}).
The first token is assumed to be the speaker ID, and the rest forms the text.}

\item{embedding}{A pre-trained vector embeddings object (e.g., a matrix of
word2vec embeddings) where \code{rownames} contain the tokens/speakers being mapped.}

\item{tokens_to_plot}{A data frame or tibble with a column named \code{token}
containing a character vector of tokens (e.g., important words) whose
embeddings should also be reduced and plotted as labels.}

\item{speaker_identifier}{A character string prefix used to identify the
speaker tokens. This is used in the internal filtering step. Defaults to \code{"speaker"}.}

\item{retain_threshold}{An integer threshold for the minimum number of
quotes a speaker must have to be included in the final plot. Defaults to \code{5}.}

\item{umap_seed}{An integer seed for the random number generator used by UMAP
to ensure reproducibility. Defaults to \code{42}.}

\item{n_neighbors}{An integer specifying the number of nearest neighbors for
the UMAP algorithm. Defaults to \code{40}.}

\item{min_dist}{A numeric value specifying the minimum distance parameter for
the UMAP algorithm. Defaults to \code{0.01}.}
}
\value{
A \code{list} containing two tibbles:
\itemize{
\item \code{speakers}: Data for the filtered speakers, including \code{author},
\code{n_quotes}, and UMAP coordinates (\code{X1}, \code{X2}).
\item \code{words}: Data for the \code{tokens_to_plot}, including \code{words}
(the token) and UMAP coordinates (\code{X1}, \code{X2}).
}
}
\description{
This function performs a comprehensive pipeline: loading speaker data from a file
path or character vector, aggregating quotes by speaker, filtering speakers based
on quote count, retrieving their combined vector embeddings, and applying UMAP
for dimensionality reduction. It processes and returns the UMAP coordinates for
both the filtered speakers and a set of input tokens for visualization.
}
\details{
The function relies on \code{tidyverse}, \code{umap}, and requires the
\code{embedding} object to be a matrix compatible with the UMAP input.

\strong{Input Flexibility:} If \code{class(data)} is \code{"speakers_text"}, the
input is treated as an inline character vector; otherwise, it is treated as a file path.
}
\examples{
\dontrun{
library(dplyr)
library(umap)

# 1. Setup Dummy Data
# Create a dummy text vector and set its class for inline processing
dummy_text_vector <- c(
  "speaker_A this is the first quote",
  "speaker_B second quote here",
  "speaker_A third line quote",
  "speaker_A another quote",
  "speaker_C fifth quote"
)
class(dummy_text_vector) <- "speakers_text"

# Create dummy embeddings (assuming 5 tokens/authors and 10 dimensions)
vocab <- c("speaker_A", "speaker_B", "speaker_C", "word1", "word2")
dummy_embedding <- matrix(
  rnorm(length(vocab) * 10),
  nrow = length(vocab),
  dimnames = list(vocab, NULL)
)

# Create dummy tokens to plot
dummy_tokens_to_plot <- tibble(token = c("word1", "word2"))

# 2. Run the processing function
landscape_data <- speaker_landscapes(
  data = dummy_text_vector,
  embedding = dummy_embedding,
  tokens_to_plot = dummy_tokens_to_plot,
  retain_threshold = 2
)
print(landscape_data$speakers)
print(landscape_data$words)

# 3. Plot the result (requires plot_speaker_landscapes function)
# plot_speaker_landscapes(landscape_data)
}
}
